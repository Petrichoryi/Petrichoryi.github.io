<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hello,Petrichoryi!</title>
    <link>https://example.com/post/</link>
    <description>Recent content in Posts on Hello,Petrichoryi!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 May 2021 20:50:58 +0800</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>js常用设计模式(一)</title>
      <link>https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/</link>
      <pubDate>Thu, 20 May 2021 20:50:58 +0800</pubDate>
      
      <guid>https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/</guid>
      <description>设计原则 单一设计原则：一个对象或方法只做一件事情。应该把对象或方法划分成较小的粒度。
最少知识原则：一个软件实体应当尽可能少地与其他实体发生相互作用。应当最少减少对象之间的交互。
开放-封闭原则：软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。
设计模式 什么是设计模式？
 假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式。
 学习设计模式，便于写出可复用和可维护性高的程序。
设计模式的原则：找出程序中变化的地方，并将变化封装起来。
1.单例模式 定义：保证一个类只有一个实例，并提供一个访问它的全局访问点。
**核心：**确保只有一个实例，并提供全局访问。
实现：用一个变量来标识实例是否已经存在，如果存在，则直接返回已经创建好的实例，反之就创建一个对象。
使用闭包持久保存上一次的执行结果，在之后的调用中直接返回。
var getSingle = function (fn) { // 创建单例方法  var result // 通过闭包保存创建过的对象  return function () { return result || (result = fn.apply(this, arguments)) } } var createPerson = getSingle(function (name) { return {name: name} }) var person1 = createPerson(&amp;#39;张三&amp;#39;) var person2 = createPerson(&amp;#39;李四&amp;#39;) console.log(person1, person2); // {name: &amp;#39;张三&amp;#39;} {name: &amp;#39;张三&amp;#39;} 2.</description>
    </item>
    
    <item>
      <title>前端安全问题</title>
      <link>https://example.com/p/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</guid>
      <description>1.跨站脚本攻击XSS**（Cross-Site Scripting）**
造成的危害：
 利用虚假输入表单骗取用户个人信息 利用脚本窃取cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求 显示伪造的文章或图片  根据攻击的来源，XSS 攻击可分为反射型、存储型和 DOM 型三种：
  反射型XSS
发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。
1.攻击者给用户发送一个恶意构造了的web的URL
2.用户点击并查看这个URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器
3.用户获取到一个具有漏洞的HTML页面并显示在本地浏览器中，恶意代码也被执行
4.漏洞HTML 页面执行恶意JavaScript脚本，将用户信息盗取发送给攻击者，或者篡改用户看到的数据，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
反射型XSS防御：  ​ 1.web页面渲染的所有内容或者渲染的数据都必须来自于服务端。
​	2.尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。
​	3.尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。
​ 4.前端渲染的时候对任何字段都需要做escape转义编码。
  存储型XSS
存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端，每一个访问特定网页的用户都会被攻击。(是一种持久型XSS漏洞)一般存在于Form表单提交等交互功能，如文章留言，提交文本信息等。
具体的攻击过程：
​ 1、攻击者将恶意代码提交到目标网站的数据库中。
​ 2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
​ 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
​ 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
攻击成功需要同时满足下面的条件：
 POST请求提交表单后端没做转义直接入库 后端从数据库中取出数据没做转义直接输出给前端 前端拿到后端数据没做转义直接渲染成 DOM  存储型XSS防御：   后端需要对提交的数据进行过滤。 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。 纯前端渲染，把代码和数据分隔开。渲染过程：浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据；然后浏览器执行 HTML 中的 JavaScript；JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。    DOM型XSS</description>
    </item>
    
  </channel>
</rss>
