<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on Hello,Petrichoryi!</title>
    <link>https://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Hello,Petrichoryi!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 May 2021 21:27:07 +0800</lastBuildDate><atom:link href="https://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>js常用设计模式(二)</title>
      <link>https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C/</link>
      <pubDate>Thu, 20 May 2021 21:27:07 +0800</pubDate>
      
      <guid>https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C/</guid>
      <description>5.发布-订阅模式 定义：又称观察者模式，定义了对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。应用场景：dom事件通知机制(document.addEventListener)，以及vue框架中数据改变时自动刷新dom的双向绑定机制。
优点
一为时间上的解耦，二为对象之间的解耦。可以用在异步编程中与MV*框架中.
缺点
创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销
弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解.
例：
小A在公司C完成了笔试及面试，小B也在公司C完成了笔试。他们焦急地等待结果，每隔半天就电话询问公司C，导致公司C很不耐烦。
一种解决办法是 AB直接把联系方式留给C，有结果的话C自然会通知AB。
这里的“询问”属于显示调用，“留给”属于订阅，“通知”属于发布。
// 观察者 var observer = { // 订阅集合  subscribes: [], // 订阅  subscribe: function(type, fn) { if (!this.subscribes[type]) { this.subscribes[type] = []; } // 收集订阅者的处理  typeof fn === &amp;#39;function&amp;#39; &amp;amp;&amp;amp; this.subscribes[type].push(fn); }, // 发布 可能会携带一些信息发布出去  publish: function() { var type = [].shift.call(arguments), fns = this.subscribes[type]; // 不存在的订阅类型，以及订阅时未传入处理回调的  if (!fns || !fns.length) { return; } // 挨个处理调用  for (var i = 0; i &amp;lt; fns.</description>
    </item>
    
    <item>
      <title>js常用设计模式(一)</title>
      <link>https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/</link>
      <pubDate>Thu, 20 May 2021 20:50:58 +0800</pubDate>
      
      <guid>https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/</guid>
      <description>设计原则 单一设计原则：一个对象或方法只做一件事情。应该把对象或方法划分成较小的粒度。
最少知识原则：一个软件实体应当尽可能少地与其他实体发生相互作用。应当最少减少对象之间的交互。
开放-封闭原则：软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。
设计模式 什么是设计模式？
 假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式。
 学习设计模式，便于写出可复用和可维护性高的程序。
设计模式的原则：找出程序中变化的地方，并将变化封装起来。
1.单例模式 定义：保证一个类只有一个实例，并提供一个访问它的全局访问点。
**核心：**确保只有一个实例，并提供全局访问。
实现：用一个变量来标识实例是否已经存在，如果存在，则直接返回已经创建好的实例，反之就创建一个对象。
使用闭包持久保存上一次的执行结果，在之后的调用中直接返回。
var getSingle = function (fn) { // 创建单例方法  var result // 通过闭包保存创建过的对象  return function () { return result || (result = fn.apply(this, arguments)) } } var createPerson = getSingle(function (name) { return {name: name} }) var person1 = createPerson(&amp;#39;张三&amp;#39;) var person2 = createPerson(&amp;#39;李四&amp;#39;) console.log(person1, person2); // {name: &amp;#39;张三&amp;#39;} {name: &amp;#39;张三&amp;#39;} 2.</description>
    </item>
    
  </channel>
</rss>
