[{"content":"5.发布-订阅模式 定义：又称观察者模式，定义了对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。应用场景：dom事件通知机制(document.addEventListener)，以及vue框架中数据改变时自动刷新dom的双向绑定机制。\n优点\n一为时间上的解耦，二为对象之间的解耦。可以用在异步编程中与MV*框架中.\n缺点\n创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销\n弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解.\n例：\n小A在公司C完成了笔试及面试，小B也在公司C完成了笔试。他们焦急地等待结果，每隔半天就电话询问公司C，导致公司C很不耐烦。\n一种解决办法是 AB直接把联系方式留给C，有结果的话C自然会通知AB。\n这里的“询问”属于显示调用，“留给”属于订阅，“通知”属于发布。\n// 观察者 var observer = { // 订阅集合  subscribes: [], // 订阅  subscribe: function(type, fn) { if (!this.subscribes[type]) { this.subscribes[type] = []; } // 收集订阅者的处理  typeof fn === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; this.subscribes[type].push(fn); }, // 发布 可能会携带一些信息发布出去  publish: function() { var type = [].shift.call(arguments), fns = this.subscribes[type]; // 不存在的订阅类型，以及订阅时未传入处理回调的  if (!fns || !fns.length) { return; } // 挨个处理调用  for (var i = 0; i \u0026lt; fns.length; ++i) { fns[i].apply(this, arguments); } }, // 删除订阅  remove: function(type, fn) { // 删除全部  if (typeof type === \u0026#39;undefined\u0026#39;) { this.subscribes = []; return; } var fns = this.subscribes[type]; // 不存在的订阅类型，以及订阅时未传入处理回调的  if (!fns || !fns.length) { return; } if (typeof fn === \u0026#39;undefined\u0026#39;) { fns.length = 0; return; } // 挨个处理删除  for (var i = 0; i \u0026lt; fns.length; ++i) { if (fns[i] === fn) { fns.splice(i, 1); } } } }; // 订阅岗位列表 function jobListForA(jobs) { console.log(\u0026#39;A\u0026#39;, jobs); } function jobListForB(jobs) { console.log(\u0026#39;B\u0026#39;, jobs); } // A订阅了岗位信息 observer.subscribe(\u0026#39;job\u0026#39;, jobListForA); // B订阅了岗位信息 observer.subscribe(\u0026#39;job\u0026#39;, jobListForB); // A订阅了笔试成绩 observer.subscribe(\u0026#39;examinationA\u0026#39;, function(score) { console.log(score); }); // B订阅了笔试成绩 observer.subscribe(\u0026#39;examinationB\u0026#39;, function(score) { console.log(score); }); // A订阅了面试结果 observer.subscribe(\u0026#39;interviewA\u0026#39;, function(result) { console.log(result); }); observer.publish(\u0026#39;examinationA\u0026#39;, 100); // 100 observer.publish(\u0026#39;examinationB\u0026#39;, 80); // 80 observer.publish(\u0026#39;interviewA\u0026#39;, \u0026#39;备用\u0026#39;); // 备用  observer.publish(\u0026#39;job\u0026#39;, [\u0026#39;前端\u0026#39;, \u0026#39;后端\u0026#39;, \u0026#39;测试\u0026#39;]); // 输出A和B的岗位  // B取消订阅了笔试成绩 observer.remove(\u0026#39;examinationB\u0026#39;); // A取消订阅了岗位 observer.remove(\u0026#39;job\u0026#39;, jobListForA); observer.publish(\u0026#39;examinationB\u0026#39;, 80); // 没有可匹配的订阅，无输出 observer.publish(\u0026#39;job\u0026#39;, [\u0026#39;前端\u0026#39;, \u0026#39;后端\u0026#39;, \u0026#39;测试\u0026#39;]); // 输出B的岗位 依次输出：\n100 80 备用 A [ \u0026#39;前端\u0026#39;, \u0026#39;后端\u0026#39;, \u0026#39;测试\u0026#39; ] B [ \u0026#39;前端\u0026#39;, \u0026#39;后端\u0026#39;, \u0026#39;测试\u0026#39; ] B [ \u0026#39;前端\u0026#39;, \u0026#39;后端\u0026#39;, \u0026#39;测试\u0026#39; ] 6.命令模式 定义：将一组行为抽象为对象并提供执行、撤销的方法。解决它与调用者之间的耦合关系。(松耦合)。\n核心：命令中带有execute执行、undo撤销、redo重做等相关命令方法，建议显示地指示这些方法名。\n该模式适用于需要向某些对象发出请求，但不知道接收者是谁，也不知道要执行哪些操作。\n例：\n一个自增命令，提供执行、撤销、重做的功能\n// 自增 function IncrementCommand() { // 当前值  this.val = 0; // 命令栈  this.stack = []; // 栈指针位置  this.stackPosition = -1; }; IncrementCommand.prototype = { constructor: IncrementCommand, // 执行  execute: function() { this._clearRedo(); // 定义执行的处理  var command = function() { this.val += 2; }.bind(this); // 执行并缓存起来  command(); this.stack.push(command); this.stackPosition++; this.getValue(); }, canUndo: function() { return this.stackPosition \u0026gt;= 0; }, canRedo: function() { return this.stackPosition \u0026lt; this.stack.length - 1; }, // 撤销  undo: function() { if (!this.canUndo()) { return; } this.stackPosition--; // 命令的撤销，与执行的处理相反  var command = function() { this.val -= 2; }.bind(this); // 撤销后不需要缓存  command(); this.getValue(); }, // 重做  redo: function() { if (!this.canRedo()) { return; } // 执行栈顶的命令  this.stack[++this.stackPosition](); this.getValue(); }, // 在执行时，已经撤销的部分不能再重做  _clearRedo: function() { this.stack = this.stack.slice(0, this.stackPosition + 1); }, // 获取当前值  getValue: function() { console.log(this.val); } }; //实例化测试，模拟执行、撤销、重做的操作 var incrementCommand = new IncrementCommand(); // 模拟事件触发，执行命令 var eventTrigger = { // 某个事件的处理中，直接调用命令的处理方法  increment: function() { incrementCommand.execute(); }, incrementUndo: function() { incrementCommand.undo(); }, incrementRedo: function() { incrementCommand.redo(); } }; eventTrigger[\u0026#39;increment\u0026#39;](); // 2 eventTrigger[\u0026#39;increment\u0026#39;](); // 4  eventTrigger[\u0026#39;incrementUndo\u0026#39;](); // 2  eventTrigger[\u0026#39;increment\u0026#39;](); // 4  eventTrigger[\u0026#39;incrementUndo\u0026#39;](); // 2 eventTrigger[\u0026#39;incrementUndo\u0026#39;](); // 0 eventTrigger[\u0026#39;incrementUndo\u0026#39;](); // 无输出  eventTrigger[\u0026#39;incrementRedo\u0026#39;](); // 2 eventTrigger[\u0026#39;incrementRedo\u0026#39;](); // 4 eventTrigger[\u0026#39;incrementRedo\u0026#39;](); // 无输出  eventTrigger[\u0026#39;increment\u0026#39;](); // 6 7.组合模式 定义：是用小的对象来构建更大的对象，而这些小的对象本身也许是由更小的‘孙对象’构成的。\n核心：\n可以用树形结构来表示这种“部分- 整体”的层次结构。\n调用组合对象 的execute方法，程序会递归调用组合对象 下面的叶对象的execute方法\n组合模式不是父子关系，它是一种HAS-A（聚合）的关系，将请求委托给 它所包含的所有叶对象。基于这种委托，就需要保证组合对象和叶对象拥有相同的 接口。\n例如我们通过命令模式定义了一系列的命令，并且希望组合这些命令形成一个命令宏统一的执行。\n例：\n// 定义一些命令 var openDoorCommand = { execute: function(){ console.log(\u0026#39;开门\u0026#39;) } } var openPcCommand = { execute: function(){ console.log(\u0026#39;开电脑\u0026#39;) } } var openLolCommand = { execute: function(){ console.log(\u0026#39;撸一局\u0026#39;) } } // 定义命令宏组合命令 var MarcoCommand = { list: [], add: function (command) { this.list.push(command) }, execute: function () { this.list.forEach(function(command) { command.execute() }) } } MarcoCommand.add(openDoorCommand) MarcoCommand.add(openPcCommand) MarcoCommand.add(openLolCommand) MarcoCommand.execute() // 开门 开电脑 撸一局 优点\n可以方便地构造一棵树来表示对象的部分-整体 结构。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一一致的操作。\n缺点\n创建出来的对象长得都差不多，可能会使代码不好理解，创建太多的对象对性能也会有一些影响.\n8.工厂模式 定义：不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，这个函数被视为一个工厂。\n工厂模式的目标：\n 当创建相似对象时执行重复的操作 当编译时不知道具体类型的情况下，为工厂客户提供一个创建对象的接口  工厂模式的分类：简单工厂、工厂方法、抽象工厂\n  简单工厂是将创建对象的步骤放在父类进行，由工厂对象决定创建某一种产品对象类的实例。根据参数的不同返回不同类的实例\n像在网站中有的页面是需要根据账号等级来决定是否有浏览权限的,账号等级越高可浏览的就越多。\nvar UserFactory = function (role) { function Admin() { this.name = \u0026#34;管理员\u0026#34;, this.viewPage = [\u0026#39;首页\u0026#39;, \u0026#39;查询\u0026#39;, \u0026#39;权限管理\u0026#39;] } function User() { this.name = \u0026#39;普通用户\u0026#39;, this.viewPage = [\u0026#39;首页\u0026#39;, \u0026#39;查询\u0026#39;] } switch (role) { case \u0026#39;admin\u0026#39;: return new Admin(); break; case \u0026#39;user\u0026#39;: return new User(); break; default: throw new Error(\u0026#39;参数错误, 可选参数: admin、user\u0026#39;); } } var admin = UserFactory(\u0026#39;admin\u0026#39;); var user = UserFactory(\u0026#39;user\u0026#39;); console.log(admin.name) console.log(user.name)   工厂方法：将创建对象的方法工作推到子类中执行，也需要“根据传入的字符串来选择对应的类”。\n进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产，如果不行，那么要么新建工厂生产要么就生产不了。\n// JS设计模式之工厂方法模式  function factory(role){ if(this instanceof factory){ var a = new this[role](); return a; }else{ return new factory(role); } } factory.prototype={ \u0026#34;superAdmin\u0026#34;:function(){ this.name=\u0026#34;超级管理员\u0026#34;; this.viewPage=[\u0026#34;首页\u0026#34;,\u0026#34;发现页\u0026#34;,\u0026#34;通讯录\u0026#34;,\u0026#34;应用数据\u0026#34;,\u0026#34;权限管理\u0026#34;]; }, \u0026#34;admin\u0026#34;:function(){ this.name=\u0026#34;管理员\u0026#34;; this.viewPage=[\u0026#34;首页\u0026#34;,\u0026#34;发现页\u0026#34;,\u0026#34;通讯录\u0026#34;,\u0026#34;应用数据\u0026#34;]; }, \u0026#34;user\u0026#34;:function(){ this.name=\u0026#34;普通用户\u0026#34;; this.viewPage=[\u0026#34;首页\u0026#34;,\u0026#34;发现页\u0026#34;,\u0026#34;通讯录\u0026#34;]; } } let superAdmin = factory(\u0026#34;superAdmin\u0026#34;); console.log(superAdmin); let admin = factory(\u0026#34;admin\u0026#34;); console.log(admin); let user = factory(\u0026#34;user\u0026#34;); console.log(user);   抽象工厂\n抽象工厂是工厂模式中的工厂的抽象，可以理解为一个超级工厂，或者创建工厂的工厂，相当于工厂的上一级，和抽象类的概念有些类似，工厂是生产某些产品的具体工厂，抽象工厂则创建具有有些相同特征的一类工厂。\n  大白话解释：\n  简单工厂模式就是你给工厂什么，工厂就给你生产什么；\n  工厂方法模式就是你找工厂生产产品，工厂是外包给下级分工厂来代加工，需要先评估一下能不能代加工；能做就接，不能做就找其他工厂；\n  抽象工厂模式就是工厂接了某项产品订单但是做不了，上级集团公司新建一个工厂来专门代加工某项产品。\n  ","date":"2021-05-20T21:27:07+08:00","image":"https://example.com/js.png","permalink":"https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C/","title":"js常用设计模式(二)"},{"content":"设计原则 单一设计原则：一个对象或方法只做一件事情。应该把对象或方法划分成较小的粒度。\n最少知识原则：一个软件实体应当尽可能少地与其他实体发生相互作用。应当最少减少对象之间的交互。\n开放-封闭原则：软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。\n设计模式 什么是设计模式？\n 假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式。\n 学习设计模式，便于写出可复用和可维护性高的程序。\n设计模式的原则：找出程序中变化的地方，并将变化封装起来。\n1.单例模式 定义：保证一个类只有一个实例，并提供一个访问它的全局访问点。\n**核心：**确保只有一个实例，并提供全局访问。\n实现：用一个变量来标识实例是否已经存在，如果存在，则直接返回已经创建好的实例，反之就创建一个对象。\n使用闭包持久保存上一次的执行结果，在之后的调用中直接返回。\nvar getSingle = function (fn) { // 创建单例方法  var result // 通过闭包保存创建过的对象  return function () { return result || (result = fn.apply(this, arguments)) } } var createPerson = getSingle(function (name) { return {name: name} }) var person1 = createPerson(\u0026#39;张三\u0026#39;) var person2 = createPerson(\u0026#39;李四\u0026#39;) console.log(person1, person2); // {name: \u0026#39;张三\u0026#39;} {name: \u0026#39;张三\u0026#39;} 2.策略模式 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n核心：将算法的使用和算法的实现分离开来。\n一个基于策略模式的程序至少由两部分组成：\n第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。\n第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context 中要维持对某个策略对象的引用\n策略模式可以用于组合一系列算法，也可用于组合一系列规则。\n优点：可以有效避免多重条件语句，将一系列的方法封装起来也更直观，利于维护。\n缺点：往往策略集会比较多，我们需要事先就了解定义好所有的情况\n例：针对不同表现的员工定制策略，每个策略接受同类型的参数返回相同的结果\nvar strategies = { S(salary) { return salary * 3 }, A(salary) { return salary * 2 }, B(salary) { return salary }, C(salary) { return -salary } } var calculateBonus = function (salary, strategy) { return strategies[strategy](salary) } console.log(calculateBonus(10000, \u0026#39;S\u0026#39;)); // 30000 console.log(calculateBonus(1000, \u0026#39;C\u0026#39;)); // -1000 其他应用场景：表单验证\n3.代理模式 定义：为对象提供一个代用品或占位符，以便控制对它的访问\n核心：\n当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。\n替身对象对请求做出一些处理之后， 再把请求转交给本体对象。\n应用场景：例如 防抖动函数（debounce 常用于控制用户输入后回调函数触发的时机），节流函数（throttle 常用于控制scroll等事件的触发频率）、图片预加载\n代理模式主要有三种：保护代理、虚拟代理、缓存代理\n 保护代理主要实现了访问主体的限制行为，如过滤字符 虚拟代理在控制对主体的访问时，加入了一些额外的操作，如函数节流 缓存代理可以为一些开销大的运算结果提供暂时的缓存，提升效率  4.迭代器模式 定义：提供一种方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。\n核心：在使用迭代器模式后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。\nJS中数组的map forEach 已经内置了迭代器\n封装对象的遍历：\n//cb是回调函数 function each(obj, cb) { var value; if (Array.isArray(obj)) { for (var i = 0; i \u0026lt; obj.length; ++i) { //数组的每一个元素调用回调函数  value = cb.call(obj[i], i, obj[i]); if (value === false) { break; } } } else { for (var i in obj) { //对象的每一个属性调用回调函数  value = cb.call(obj[i], i, obj[i]); if (value === false) { break; } } } } each([1, 2, 3], function(index, value) { console.log(index, value); }); each({a: 1, b: 2}, function(index, value) { console.log(index, value); }); ","date":"2021-05-20T20:50:58+08:00","image":"https://example.com/js.png","permalink":"https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/","title":"js常用设计模式(一)"},{"content":"1.跨站脚本攻击XSS**（Cross-Site Scripting）**\n造成的危害：\n 利用虚假输入表单骗取用户个人信息 利用脚本窃取cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求 显示伪造的文章或图片  根据攻击的来源，XSS 攻击可分为反射型、存储型和 DOM 型三种：\n  反射型XSS\n发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。\n1.攻击者给用户发送一个恶意构造了的web的URL\n2.用户点击并查看这个URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器\n3.用户获取到一个具有漏洞的HTML页面并显示在本地浏览器中，恶意代码也被执行\n4.漏洞HTML 页面执行恶意JavaScript脚本，将用户信息盗取发送给攻击者，或者篡改用户看到的数据，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n反射型XSS防御：  ​ 1.web页面渲染的所有内容或者渲染的数据都必须来自于服务端。\n​\t2.尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。\n​\t3.尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。\n​ 4.前端渲染的时候对任何字段都需要做escape转义编码。\n  存储型XSS\n存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端，每一个访问特定网页的用户都会被攻击。(是一种持久型XSS漏洞)一般存在于Form表单提交等交互功能，如文章留言，提交文本信息等。\n具体的攻击过程：\n​ 1、攻击者将恶意代码提交到目标网站的数据库中。\n​ 2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n​ 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n​ 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n攻击成功需要同时满足下面的条件：\n POST请求提交表单后端没做转义直接入库 后端从数据库中取出数据没做转义直接输出给前端 前端拿到后端数据没做转义直接渲染成 DOM  存储型XSS防御：   后端需要对提交的数据进行过滤。 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。 纯前端渲染，把代码和数据分隔开。渲染过程：浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据；然后浏览器执行 HTML 中的 JavaScript；JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。    DOM型XSS\n通过 HTML DOM植入js代码，造成dom的更改，DOM类型的XSS可能是反射型也可能是储存型。\n和前两种XSS的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端自身的安全漏洞，而其他两种XSS属于服务端的安全漏洞。\n攻击过程如下：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  DOM型XSS防御：​ 1、在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n​\t2.Http only：eb应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。\n​\t3.对输入要求格式严谨检查过滤\n  2.点击劫持攻击(ClickJacking)\n攻击者将需要攻击的网站通过iframe嵌套的方式嵌入到自己的网页中，并将iframe设为透明，在页面中透出一个按钮诱导用户点击。\n网络劫持一般分为两种:\n DNS劫持: (输入京东被强制跳转到淘宝这就属于dns劫持)  DNS强制解析: 通过修改运营商的本地DNS记录，来引导用户流量到缓存服务器； 302跳转的方式: 通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的,再对劫持的内存发起302跳转的回复，引导用户获取内容。   HTTP劫持: (访问谷歌但是一直有贪玩蓝月的广告)，由于http明文传输，运营商会修改你的http响应内容(即加广告)。  点击劫持防御：  在HTTP头中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 中。\nDENY：不能被所有网站嵌套或加载；\nSAMEORIGIN：只能被同域网站嵌套或加载；\nALLOW-FROM URL：可以被指定网站嵌套或加载。\n  使用 FrameBusting **代码：**使用 JavaScript 脚本阻止恶意网站载入网页\n  使用认证码认证用户\n  3.CSRF(跨站请求伪造)\n是建立在浏览器和Web服务器的会话中。\n攻击过程：\n 用户登录受信任网站，输入用户名和密码 受信任网站通过验证请求后，生成用户的cookie 用户没有退出受信任网站时访问危险网站，危险网站利用用户的cookie信息，向受信任网站发送恶意请求  防御方式\n1.验证http协议中的referer字段，它记录了该http请求的来源地址，通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击\n2.添加验证码，提交请求时进行人工确认\n3.在请求地址中添加token验证\n关键：在请求中放入攻击者不能伪造的信息，并且该信息不在cookie中。系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务.\n","date":"2021-05-09T00:00:00Z","image":"https://example.com/1.jpg","permalink":"https://example.com/p/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","title":"前端安全问题"}]