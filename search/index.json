[{"content":"设计原则 单一设计原则：一个对象或方法只做一件事情。应该把对象或方法划分成较小的粒度。\n最少知识原则：一个软件实体应当尽可能少地与其他实体发生相互作用。应当最少减少对象之间的交互。\n开放-封闭原则：软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。\n设计模式 什么是设计模式？\n 假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式。\n 学习设计模式，便于写出可复用和可维护性高的程序。\n设计模式的原则：找出程序中变化的地方，并将变化封装起来。\n1.单例模式 定义：保证一个类只有一个实例，并提供一个访问它的全局访问点。\n**核心：**确保只有一个实例，并提供全局访问。\n实现：用一个变量来标识实例是否已经存在，如果存在，则直接返回已经创建好的实例，反之就创建一个对象。\n使用闭包持久保存上一次的执行结果，在之后的调用中直接返回。\nvar getSingle = function (fn) { // 创建单例方法  var result // 通过闭包保存创建过的对象  return function () { return result || (result = fn.apply(this, arguments)) } } var createPerson = getSingle(function (name) { return {name: name} }) var person1 = createPerson(\u0026#39;张三\u0026#39;) var person2 = createPerson(\u0026#39;李四\u0026#39;) console.log(person1, person2); // {name: \u0026#39;张三\u0026#39;} {name: \u0026#39;张三\u0026#39;} 2.策略模式 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n核心：将算法的使用和算法的实现分离开来。\n一个基于策略模式的程序至少由两部分组成：\n第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。\n第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context 中要维持对某个策略对象的引用\n策略模式可以用于组合一系列算法，也可用于组合一系列规则。\n优点：可以有效避免多重条件语句，将一系列的方法封装起来也更直观，利于维护。\n缺点：往往策略集会比较多，我们需要事先就了解定义好所有的情况\n例：针对不同表现的员工定制策略，每个策略接受同类型的参数返回相同的结果\nvar strategies = { S(salary) { return salary * 3 }, A(salary) { return salary * 2 }, B(salary) { return salary }, C(salary) { return -salary } } var calculateBonus = function (salary, strategy) { return strategies[strategy](salary) } console.log(calculateBonus(10000, \u0026#39;S\u0026#39;)); // 30000 console.log(calculateBonus(1000, \u0026#39;C\u0026#39;)); // -1000 其他应用场景：表单验证\n3.代理模式 定义：为对象提供一个代用品或占位符，以便控制对它的访问\n核心：\n当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。\n替身对象对请求做出一些处理之后， 再把请求转交给本体对象。\n应用场景：例如 防抖动函数（debounce 常用于控制用户输入后回调函数触发的时机），节流函数（throttle 常用于控制scroll等事件的触发频率）、图片预加载\n代理模式主要有三种：保护代理、虚拟代理、缓存代理\n 保护代理主要实现了访问主体的限制行为，如过滤字符 虚拟代理在控制对主体的访问时，加入了一些额外的操作，如函数节流 缓存代理可以为一些开销大的运算结果提供暂时的缓存，提升效率  4.迭代器模式 定义：提供一种方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。\n核心：在使用迭代器模式后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。\nJS中数组的map forEach 已经内置了迭代器\n封装对象的遍历：\n//cb是回调函数 function each(obj, cb) { var value; if (Array.isArray(obj)) { for (var i = 0; i \u0026lt; obj.length; ++i) { //数组的每一个元素调用回调函数  value = cb.call(obj[i], i, obj[i]); if (value === false) { break; } } } else { for (var i in obj) { //对象的每一个属性调用回调函数  value = cb.call(obj[i], i, obj[i]); if (value === false) { break; } } } } each([1, 2, 3], function(index, value) { console.log(index, value); }); each({a: 1, b: 2}, function(index, value) { console.log(index, value); }); ","date":"2021-05-20T20:50:58+08:00","image":"https://example.com/js.png","permalink":"https://example.com/p/js%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/","title":"js常用设计模式(一)"},{"content":"1.跨站脚本攻击XSS**（Cross-Site Scripting）**\n造成的危害：\n 利用虚假输入表单骗取用户个人信息 利用脚本窃取cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求 显示伪造的文章或图片  根据攻击的来源，XSS 攻击可分为反射型、存储型和 DOM 型三种：\n  反射型XSS\n发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。\n1.攻击者给用户发送一个恶意构造了的web的URL\n2.用户点击并查看这个URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器\n3.用户获取到一个具有漏洞的HTML页面并显示在本地浏览器中，恶意代码也被执行\n4.漏洞HTML 页面执行恶意JavaScript脚本，将用户信息盗取发送给攻击者，或者篡改用户看到的数据，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n反射型XSS防御：  ​ 1.web页面渲染的所有内容或者渲染的数据都必须来自于服务端。\n​\t2.尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。\n​\t3.尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。\n​ 4.前端渲染的时候对任何字段都需要做escape转义编码。\n  存储型XSS\n存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端，每一个访问特定网页的用户都会被攻击。(是一种持久型XSS漏洞)一般存在于Form表单提交等交互功能，如文章留言，提交文本信息等。\n具体的攻击过程：\n​ 1、攻击者将恶意代码提交到目标网站的数据库中。\n​ 2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n​ 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n​ 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n攻击成功需要同时满足下面的条件：\n POST请求提交表单后端没做转义直接入库 后端从数据库中取出数据没做转义直接输出给前端 前端拿到后端数据没做转义直接渲染成 DOM  存储型XSS防御：   后端需要对提交的数据进行过滤。 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。 纯前端渲染，把代码和数据分隔开。渲染过程：浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据；然后浏览器执行 HTML 中的 JavaScript；JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。    DOM型XSS\n通过 HTML DOM植入js代码，造成dom的更改，DOM类型的XSS可能是反射型也可能是储存型。\n和前两种XSS的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端自身的安全漏洞，而其他两种XSS属于服务端的安全漏洞。\n攻击过程如下：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  DOM型XSS防御：​ 1、在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n​\t2.Http only：eb应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。\n​\t3.对输入要求格式严谨检查过滤\n  2.点击劫持攻击(ClickJacking)\n攻击者将需要攻击的网站通过iframe嵌套的方式嵌入到自己的网页中，并将iframe设为透明，在页面中透出一个按钮诱导用户点击。\n网络劫持一般分为两种:\n DNS劫持: (输入京东被强制跳转到淘宝这就属于dns劫持)  DNS强制解析: 通过修改运营商的本地DNS记录，来引导用户流量到缓存服务器； 302跳转的方式: 通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的,再对劫持的内存发起302跳转的回复，引导用户获取内容。   HTTP劫持: (访问谷歌但是一直有贪玩蓝月的广告)，由于http明文传输，运营商会修改你的http响应内容(即加广告)。  点击劫持防御：  在HTTP头中加入 X-FRAME-OPTIONS 属性，此属性控制页面是否可被嵌入 iframe 中。\nDENY：不能被所有网站嵌套或加载；\nSAMEORIGIN：只能被同域网站嵌套或加载；\nALLOW-FROM URL：可以被指定网站嵌套或加载。\n  使用 FrameBusting **代码：**使用 JavaScript 脚本阻止恶意网站载入网页\n  使用认证码认证用户\n  3.CSRF(跨站请求伪造)\n是建立在浏览器和Web服务器的会话中。\n攻击过程：\n 用户登录受信任网站，输入用户名和密码 受信任网站通过验证请求后，生成用户的cookie 用户没有退出受信任网站时访问危险网站，危险网站利用用户的cookie信息，向受信任网站发送恶意请求  防御方式\n1.验证http协议中的referer字段，它记录了该http请求的来源地址，通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击\n2.添加验证码，提交请求时进行人工确认\n3.在请求地址中添加token验证\n关键：在请求中放入攻击者不能伪造的信息，并且该信息不在cookie中。系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务.\n","date":"2021-05-09T00:00:00Z","image":"https://example.com/1.jpg","permalink":"https://example.com/p/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","title":"前端安全问题"}]